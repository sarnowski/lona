// SPDX-License-Identifier: GPL-3.0-or-later
// Copyright 2026 Tobias Sarnowski

//! Library loading from embedded tar archive.
//!
//! The Lona standard library (`lonalib.tar`) is embedded at compile time
//! and provides namespace files for the VM to load.
//!
//! # Namespace Resolution
//!
//! Namespaces are resolved to file paths following Clojure conventions:
//! - `lona.core` → `lona/core.lona`
//! - `my.app.server` → `my/app/server.lona`

#[cfg(test)]
mod loader_test;

pub use tar_no_std::ArchiveEntry;
use tar_no_std::TarArchiveRef;

/// Embedded lonalib.tar archive bytes.
///
/// This is generated by build.rs from the `lib/` directory.
static LONALIB_TAR: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/lonalib.tar"));

// =============================================================================
// NamespaceSource trait
// =============================================================================

/// Abstraction for namespace file lookup.
///
/// Enables multiple backend implementations (embedded tar, filesystem, etc.)
/// to provide namespace source code to the VM.
pub trait NamespaceSource {
    /// Resolve a namespace to its source bytes.
    ///
    /// Converts namespace notation (e.g., `lona.core`) to file path
    /// (e.g., `lona/core.lona`) and returns the file contents.
    ///
    /// Returns `None` if the namespace is not found.
    fn resolve(&self, namespace: &str) -> Option<&[u8]>;
}

// =============================================================================
// Namespace path conversion
// =============================================================================

/// Check if a namespace matches a tar entry path.
///
/// Compares namespace notation (`lona.core`) with file path (`lona/core.lona`),
/// handling the `./` prefix that tar may add.
///
/// This function avoids allocation by comparing byte-by-byte.
fn namespace_matches_path(namespace: &str, path: &str) -> bool {
    // Empty namespace is invalid
    if namespace.is_empty() {
        return false;
    }

    // Strip optional "./" prefix from tar paths
    let path = path.strip_prefix("./").unwrap_or(path);

    // Must have .lona extension
    let Some(path_stem) = path.strip_suffix(".lona") else {
        return false;
    };

    // Compare byte by byte: '.' in namespace maps ONLY to '/' in path
    let ns_bytes = namespace.as_bytes();
    let path_bytes = path_stem.as_bytes();

    // Must be same length
    if ns_bytes.len() != path_bytes.len() {
        return false;
    }

    // Compare each byte
    for (ns_byte, path_byte) in ns_bytes.iter().zip(path_bytes.iter()) {
        let matches = match (ns_byte, path_byte) {
            // Namespace '.' must match path '/' (enforces directory structure)
            (b'.', b'/') => true,
            (b'.', _) => false, // '.' in namespace must not match anything else
            // Same character (but namespace cannot have '.')
            (a, b) => a == b,
        };
        if !matches {
            return false;
        }
    }
    true
}

// =============================================================================
// TarSource
// =============================================================================

/// Source for loading namespaces from the embedded tar archive.
pub struct TarSource<'a> {
    archive: TarArchiveRef<'a>,
}

/// Error when creating a `TarSource`.
#[derive(Debug, Clone, Copy)]
pub struct TarSourceError;

impl TarSource<'static> {
    /// Create a new `TarSource` from the embedded archive.
    ///
    /// # Errors
    ///
    /// Returns an error if the embedded archive is corrupt.
    pub fn embedded() -> Result<Self, TarSourceError> {
        let archive = TarArchiveRef::new(LONALIB_TAR).map_err(|_| TarSourceError)?;
        Ok(Self { archive })
    }
}

impl<'a> TarSource<'a> {
    /// Iterate over all entries in the archive.
    ///
    /// Each entry provides access to filename and data.
    /// Use `entry.filename().as_str()` to get the name and `entry.data()` for contents.
    pub fn entries(&self) -> impl Iterator<Item = ArchiveEntry<'a>> {
        self.archive.entries()
    }
}

impl NamespaceSource for TarSource<'_> {
    fn resolve(&self, namespace: &str) -> Option<&[u8]> {
        // Linear scan through tar entries (acceptable for small archives)
        for entry in self.archive.entries() {
            // Bind filename to extend its lifetime
            let filename_tar = entry.filename();
            let Ok(filename) = filename_tar.as_str() else {
                continue;
            };

            if namespace_matches_path(namespace, filename) {
                return Some(entry.data());
            }
        }
        None
    }
}

// =============================================================================
// ChainedSource
// =============================================================================

/// Combines multiple namespace sources with priority ordering.
///
/// Sources are searched in order; the first match wins.
/// This enables patterns like "local filesystem first, then embedded".
pub struct ChainedSource<'a> {
    sources: &'a [&'a dyn NamespaceSource],
}

impl<'a> ChainedSource<'a> {
    /// Create a new `ChainedSource` from a slice of sources.
    ///
    /// Sources are searched in order; first match wins.
    pub const fn new(sources: &'a [&'a dyn NamespaceSource]) -> Self {
        Self { sources }
    }
}

impl NamespaceSource for ChainedSource<'_> {
    fn resolve(&self, namespace: &str) -> Option<&[u8]> {
        for source in self.sources {
            if let Some(bytes) = source.resolve(namespace) {
                return Some(bytes);
            }
        }
        None
    }
}
